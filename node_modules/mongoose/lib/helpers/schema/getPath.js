'use strict';

<<<<<<< HEAD
/*!
 * Behaves like `Schema#path()`, except for it also digs into arrays without
 * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.
 */

module.exports = function getPath(schema, path) {
=======
const numberRE = /^\d+$/;

/**
 * Behaves like `Schema#path()`, except for it also digs into arrays without
 * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.
 * @api private
 */

module.exports = function getPath(schema, path, discriminatorValueMap) {
>>>>>>> test
  let schematype = schema.path(path);
  if (schematype != null) {
    return schematype;
  }
<<<<<<< HEAD

=======
>>>>>>> test
  const pieces = path.split('.');
  let cur = '';
  let isArray = false;

  for (const piece of pieces) {
<<<<<<< HEAD
    if (/^\d+$/.test(piece) && isArray) {
=======
    if (isArray && numberRE.test(piece)) {
>>>>>>> test
      continue;
    }
    cur = cur.length === 0 ? piece : cur + '.' + piece;

    schematype = schema.path(cur);
<<<<<<< HEAD
    if (schematype != null && schematype.schema) {
      schema = schematype.schema;
      cur = '';
      if (schematype.$isMongooseDocumentArray) {
        isArray = true;
      }
=======
    if (schematype?.schema) {
      schema = schematype.schema;
      if (!isArray && schematype.$isMongooseDocumentArray) {
        isArray = true;
      }
      if (discriminatorValueMap && discriminatorValueMap[cur]) {
        schema = schema.discriminators[discriminatorValueMap[cur]] ?? schema;
      }
      cur = '';
    } else if (schematype?.instance === 'Mixed') {
      // If we found a mixed path, no point in digging further, the end result is always Mixed
      break;
>>>>>>> test
    }
  }

  return schematype;
<<<<<<< HEAD
};
=======
};
>>>>>>> test
